{"ast":null,"code":"import * as bcrypt from 'bcryptjs';\nimport * as crypto from 'crypto';\nimport * as jwt from 'jsonwebtoken';\nimport mongoose, { model } from 'mongoose';\nimport * as sha256 from 'sha256';\nimport { userSchema } from \"./definitions\";\nconst SALT_WORK_FACTOR = 10;\nexport const loadClass = () => {\n  class User {\n    static getSecret() {\n      return process.env.JWT_TOKEN_SECRET || '';\n    }\n\n    static generatePassword(password) {\n      const hashPassword = sha256(password);\n      return bcrypt.hash(hashPassword, SALT_WORK_FACTOR);\n    }\n\n    static comparePassword(password, userPassword) {\n      const hashPassword = sha256(password);\n      return bcrypt.compare(hashPassword, userPassword);\n    }\n\n    static async generateToken() {\n      const buffer = await crypto.randomBytes(20);\n      const token = buffer.toString('hex');\n      return {\n        token,\n        expires: Date.now() + 86400000\n      };\n    }\n\n    static checkPassword(password) {\n      if (!password.match(/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/)) {\n        throw new Error('Must contain at least one number and one uppercase and lowercase letter, and at least 8 or more characters');\n      }\n    }\n\n    static async createUser({\n      firstName,\n      lastName,\n      email,\n      password\n    }) {\n      // empty string password validation\n      if (password === '') {\n        throw new Error('Password can not be empty');\n      }\n\n      this.checkPassword(password);\n      const user = await Users.create({\n        firstName,\n        lastName,\n        email,\n        // hash password\n        password: await this.generatePassword(password)\n      });\n      return user._id;\n    }\n\n    static async editProfile(_id, {\n      firstName,\n      lastName,\n      email\n    }) {\n      // Checking duplicated email\n      const exisitingUser = await Users.findOne({\n        email\n      }).lean();\n\n      if (exisitingUser) {\n        throw new Error('Email duplicated');\n      }\n\n      await Users.updateOne({\n        _id\n      }, {\n        $set: {\n          firstName,\n          lastName,\n          email\n        }\n      });\n      return Users.findOne({\n        _id\n      });\n    }\n\n    static async resetPassword({\n      token,\n      newPassword\n    }) {\n      const user = await Users.findOne({\n        resetPasswordToken: token,\n        resetPasswordExpires: {\n          $gt: Date.now()\n        }\n      });\n\n      if (!user) {\n        throw new Error('Password reset token is invalid or has expired.');\n      }\n\n      if (!newPassword) {\n        throw new Error('Password is required.');\n      }\n\n      this.checkPassword(newPassword); // set new password\n\n      await Users.findByIdAndUpdate({\n        _id: user._id\n      }, {\n        password: await this.generatePassword(newPassword),\n        resetPasswordToken: undefined,\n        resetPasswordExpires: undefined\n      });\n      return Users.findOne({\n        _id: user._id\n      });\n    }\n\n    static async changePassword({\n      _id,\n      currentPassword,\n      newPassword\n    }) {\n      // Password can not be empty string\n      if (newPassword === '') {\n        throw new Error('Password can not be empty');\n      }\n\n      this.checkPassword(newPassword);\n      const user = await Users.findOne({\n        _id\n      }).lean();\n\n      if (!user) {\n        throw new Error('User not found');\n      } // check current password ============\n\n\n      const valid = await this.comparePassword(currentPassword, user.password);\n\n      if (!valid) {\n        throw new Error('Incorrect current password');\n      } // set new password\n\n\n      await Users.findByIdAndUpdate({\n        _id: user._id\n      }, {\n        password: await this.generatePassword(newPassword)\n      });\n      return Users.findOne({\n        _id: user._id\n      });\n    }\n\n    static async forgotPassword(email) {\n      const user = await Users.findOne({\n        email\n      });\n\n      if (!user) {\n        throw new Error('Invalid email');\n      } // create the random token\n\n\n      const buffer = await crypto.randomBytes(20);\n      const token = buffer.toString('hex'); // save token & expiration date\n\n      await Users.findByIdAndUpdate({\n        _id: user._id\n      }, {\n        resetPasswordToken: token,\n        resetPasswordExpires: Date.now() + 86400000\n      });\n      return token;\n    }\n\n    static async createTokens(_user, secret) {\n      const user = {\n        _id: _user._id,\n        email: _user.email,\n        firstName: _user.firstName,\n        lastName: _user.lastName\n      };\n      const createToken = await jwt.sign({\n        user\n      }, secret, {\n        expiresIn: '1d'\n      });\n      const createRefreshToken = await jwt.sign({\n        user\n      }, secret, {\n        expiresIn: '7d'\n      });\n      return [createToken, createRefreshToken];\n    }\n\n    static async refreshTokens(refreshToken) {\n      let _id = '';\n\n      try {\n        // validate refresh token\n        const {\n          user\n        } = jwt.verify(refreshToken, this.getSecret());\n        _id = user._id; // if refresh token is expired then force to login\n      } catch (e) {\n        return {};\n      }\n\n      const dbUsers = await Users.findOne({\n        _id\n      });\n\n      if (!dbUsers) {\n        throw new Error('User not found');\n      } // recreate tokens\n\n\n      const [newToken, newRefreshToken] = await this.createTokens(dbUsers, this.getSecret());\n      return {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        user: dbUsers\n      };\n    }\n\n    static async login({\n      email,\n      password\n    }) {\n      const user = await Users.findOne({\n        email: {\n          $regex: new RegExp(`^${email}$`, 'i')\n        }\n      });\n\n      if (!user || !user.password) {\n        throw new Error('Invalid login');\n      }\n\n      const valid = await this.comparePassword(password, user.password);\n\n      if (!valid) {\n        // bad password\n        throw new Error('Invalid login');\n      } // create tokens\n\n\n      const [token, refreshToken] = await this.createTokens(user, this.getSecret());\n      return {\n        token,\n        refreshToken\n      };\n    }\n\n  }\n\n  userSchema.loadClass(User);\n  return userSchema;\n};\nloadClass();\ndelete mongoose.connection.models['users']; // tslint:disable-next-line\n\nconst Users = model('users', userSchema);\nexport default Users;","map":{"version":3,"sources":["/home/erxes/work/client/pages/api/db/models/Users.ts"],"names":["bcrypt","crypto","jwt","mongoose","model","sha256","userSchema","SALT_WORK_FACTOR","loadClass","User","getSecret","process","env","JWT_TOKEN_SECRET","generatePassword","password","hashPassword","hash","comparePassword","userPassword","compare","generateToken","buffer","randomBytes","token","toString","expires","Date","now","checkPassword","match","Error","createUser","firstName","lastName","email","user","Users","create","_id","editProfile","exisitingUser","findOne","lean","updateOne","$set","resetPassword","newPassword","resetPasswordToken","resetPasswordExpires","$gt","findByIdAndUpdate","undefined","changePassword","currentPassword","valid","forgotPassword","createTokens","_user","secret","createToken","sign","expiresIn","createRefreshToken","refreshTokens","refreshToken","verify","e","dbUsers","newToken","newRefreshToken","login","$regex","RegExp","connection","models"],"mappings":"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","sourcesContent":["import * as bcrypt from 'bcryptjs';\nimport * as crypto from 'crypto';\nimport * as jwt from 'jsonwebtoken';\nimport mongoose, { Model, model } from 'mongoose';\nimport * as sha256 from 'sha256';\nimport { IUser, IUserDocument, userSchema } from './definitions';\nconst SALT_WORK_FACTOR = 10;\n\ninterface IEditProfile {\n  firstName?: string;\n  lastName?: string;\n  email?: string;\n}\n\nexport interface IUserModel extends Model<IUserDocument> {\n  checkPassword(password: string): void;\n  getSecret(): string;\n  generateToken(): { token: string; expires: Date };\n  createUser(doc: IUser): Promise<IUserDocument>;\n  editProfile(_id: string, doc: IEditProfile): Promise<IUserDocument>;\n  generatePassword(password: string): Promise<string>;\n  comparePassword(password: string, userPassword: string): boolean;\n  resetPassword({\n    token,\n    newPassword\n  }: {\n    token: string;\n    newPassword: string;\n  }): Promise<IUserDocument>;\n  changePassword({\n    _id,\n    currentPassword,\n    newPassword\n  }: {\n    _id: string;\n    currentPassword: string;\n    newPassword: string;\n  }): Promise<IUserDocument>;\n  forgotPassword(email: string): string;\n  createTokens(_user: IUserDocument, secret: string): string[];\n  refreshTokens(\n    refreshToken: string\n  ): { token: string; refreshToken: string; user: IUserDocument };\n  login({\n    email,\n    password\n  }: {\n    email: string;\n    password?: string;\n  }): { token: string; refreshToken: string };\n}\n\nexport const loadClass = () => {\n  class User {\n    public static getSecret() {\n      return process.env.JWT_TOKEN_SECRET || '';\n    }\n\n    public static generatePassword(password: string) {\n      const hashPassword = sha256(password);\n\n      return bcrypt.hash(hashPassword, SALT_WORK_FACTOR);\n    }\n\n    public static comparePassword(password: string, userPassword: string) {\n      const hashPassword = sha256(password);\n\n      return bcrypt.compare(hashPassword, userPassword);\n    }\n\n    public static async generateToken() {\n      const buffer = await crypto.randomBytes(20);\n      const token = buffer.toString('hex');\n\n      return {\n        token,\n        expires: Date.now() + 86400000\n      };\n    }\n\n    public static checkPassword(password: string) {\n      if (!password.match(/^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/)) {\n        throw new Error(\n          'Must contain at least one number and one uppercase and lowercase letter, and at least 8 or more characters'\n        );\n      }\n    }\n\n    public static async createUser({\n      firstName,\n      lastName,\n      email,\n      password\n    }: IUser) {\n      // empty string password validation\n      if (password === '') {\n        throw new Error('Password can not be empty');\n      }\n\n      this.checkPassword(password);\n\n      const user = await Users.create({\n        firstName,\n        lastName,\n        email,\n        // hash password\n        password: await this.generatePassword(password)\n      });\n\n      return user._id;\n    }\n\n    public static async editProfile(\n      _id: string,\n      { firstName, lastName, email }: IEditProfile\n    ) {\n      // Checking duplicated email\n      const exisitingUser = await Users.findOne({ email }).lean();\n\n      if (exisitingUser) {\n        throw new Error('Email duplicated');\n      }\n\n      await Users.updateOne({ _id }, { $set: { firstName, lastName, email } });\n\n      return Users.findOne({ _id });\n    }\n\n    public static async resetPassword({\n      token,\n      newPassword\n    }: {\n      token: string;\n      newPassword: string;\n    }) {\n      const user = await Users.findOne({\n        resetPasswordToken: token,\n        resetPasswordExpires: {\n          $gt: Date.now()\n        }\n      });\n\n      if (!user) {\n        throw new Error('Password reset token is invalid or has expired.');\n      }\n\n      if (!newPassword) {\n        throw new Error('Password is required.');\n      }\n\n      this.checkPassword(newPassword);\n\n      // set new password\n      await Users.findByIdAndUpdate(\n        { _id: user._id },\n        {\n          password: await this.generatePassword(newPassword),\n          resetPasswordToken: undefined,\n          resetPasswordExpires: undefined\n        }\n      );\n\n      return Users.findOne({ _id: user._id });\n    }\n\n    public static async changePassword({\n      _id,\n      currentPassword,\n      newPassword\n    }: {\n      _id: string;\n      currentPassword: string;\n      newPassword: string;\n    }) {\n      // Password can not be empty string\n      if (newPassword === '') {\n        throw new Error('Password can not be empty');\n      }\n\n      this.checkPassword(newPassword);\n\n      const user = await Users.findOne({ _id }).lean();\n\n      if (!user) {\n        throw new Error('User not found');\n      }\n\n      // check current password ============\n      const valid = await this.comparePassword(currentPassword, user.password);\n\n      if (!valid) {\n        throw new Error('Incorrect current password');\n      }\n\n      // set new password\n      await Users.findByIdAndUpdate(\n        { _id: user._id },\n        {\n          password: await this.generatePassword(newPassword)\n        }\n      );\n\n      return Users.findOne({ _id: user._id });\n    }\n\n    public static async forgotPassword(email: string) {\n      const user = await Users.findOne({ email });\n\n      if (!user) {\n        throw new Error('Invalid email');\n      }\n\n      // create the random token\n      const buffer = await crypto.randomBytes(20);\n      const token = buffer.toString('hex');\n\n      // save token & expiration date\n      await Users.findByIdAndUpdate(\n        { _id: user._id },\n        {\n          resetPasswordToken: token,\n          resetPasswordExpires: Date.now() + 86400000\n        }\n      );\n\n      return token;\n    }\n\n    public static async createTokens(_user: IUserDocument, secret: string) {\n      const user = {\n        _id: _user._id,\n        email: _user.email,\n        firstName: _user.firstName,\n        lastName: _user.lastName\n      };\n\n      const createToken = await jwt.sign({ user }, secret, { expiresIn: '1d' });\n\n      const createRefreshToken = await jwt.sign({ user }, secret, {\n        expiresIn: '7d'\n      });\n\n      return [createToken, createRefreshToken];\n    }\n\n    public static async refreshTokens(refreshToken: string) {\n      let _id = '';\n\n      try {\n        // validate refresh token\n        const { user } = jwt.verify(refreshToken, this.getSecret());\n\n        _id = user._id;\n        // if refresh token is expired then force to login\n      } catch (e) {\n        return {};\n      }\n\n      const dbUsers = await Users.findOne({ _id });\n\n      if (!dbUsers) {\n        throw new Error('User not found');\n      }\n\n      // recreate tokens\n      const [newToken, newRefreshToken] = await this.createTokens(\n        dbUsers,\n        this.getSecret()\n      );\n\n      return {\n        token: newToken,\n        refreshToken: newRefreshToken,\n        user: dbUsers\n      };\n    }\n\n    public static async login({\n      email,\n      password\n    }: {\n      email: string;\n      password: string;\n    }) {\n      const user = await Users.findOne({\n        email: { $regex: new RegExp(`^${email}$`, 'i') }\n      });\n\n      if (!user || !user.password) {\n        throw new Error('Invalid login');\n      }\n\n      const valid = await this.comparePassword(password, user.password);\n\n      if (!valid) {\n        // bad password\n        throw new Error('Invalid login');\n      }\n\n      // create tokens\n      const [token, refreshToken] = await this.createTokens(\n        user,\n        this.getSecret()\n      );\n\n      return {\n        token,\n        refreshToken\n      };\n    }\n  }\n\n  userSchema.loadClass(User);\n\n  return userSchema;\n};\n\nloadClass();\n\ndelete mongoose.connection.models['users'];\n\n// tslint:disable-next-line\nconst Users = model<IUserDocument, IUserModel>('users', userSchema);\n\nexport default Users;\n"]},"metadata":{},"sourceType":"module"}